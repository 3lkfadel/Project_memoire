{% extends "layout.html" %}
{% set active_tab = 'logs' %}
{% block content %}

<div class="card audit">
  <div class="audit-head">
    <div>
      <h2>Journal / Audit</h2>
      <p class="muted">Événements WireGuard & système, formatés pour lecture rapide.</p>
    </div>
    <div class="actions">
      <button class="btn ghost" id="toggleView" title="Basculer table / timeline">● Timeline</button>
      <a class="btn ghost" href="{{ url_for('restart') }}">↻ Redémarrer wg0</a>
    </div>
  </div>

  <!-- Résumé (donuts) -->
  <!-- Résumé (donuts compacts) -->
<div class="summary-cards compact">
  <div class="sum card">
    <div class="sum-body small">
      <canvas id="donutInfo" width="54" height="54"></canvas>
      <div class="sum-meta">
        <div class="sum-title">Infos</div>
        <div class="sum-value" id="countInfo">0</div>
      </div>
    </div>
  </div>
  <div class="sum card">
    <div class="sum-body small">
      <canvas id="donutWarn" width="54" height="54"></canvas>
      <div class="sum-meta">
        <div class="sum-title">Avert.</div>
        <div class="sum-value" id="countWarn">0</div>
      </div>
    </div>
  </div>
  <div class="sum card">
    <div class="sum-body small">
      <canvas id="donutErr" width="54" height="54"></canvas>
      <div class="sum-meta">
        <div class="sum-title">Erreurs</div>
        <div class="sum-value" id="countErr">0</div>
      </div>
    </div>
  </div>
</div>

  <!-- Toolbar -->
  <div class="audit-toolbar">
    <div class="pill-group">
      <button class="pill is-active" data-source="systemd">Service (systemd)</button>
      <button class="pill" data-source="wg">WireGuard</button>
      <button class="pill" data-source="kernel">Kernel</button>
    </div>

    <div class="input icon-left">
      <svg viewBox="0 0 24 24" class="icon"><path d="M21 21l-4.3-4.3M10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16z"/></svg>
      <input id="q" type="search" placeholder="Rechercher (peer pubkey, port, erreur…)">
    </div>

    <div class="select">
      <select id="lines">
        <option value="200">200 lignes</option>
        <option value="500">500 lignes</option>
        <option value="1000">1000 lignes</option>
      </select>
    </div>

    <label class="chk"><input id="live" type="checkbox"> Live</label>

    <button class="btn" id="export">Exporter</button>
  </div>

  <!-- Table / Timeline -->
  <div class="audit-table-wrap" id="tableWrap">
    <table class="audit-table" id="auditTable">
      <thead>
        <tr>
          <th style="width:28px"></th>
          <th style="width:180px">Horodatage</th>
          <th style="width:110px">Source</th>
          <th style="width:110px">Type</th>
          <th>Message</th>
          <th style="width:130px">Acteur / IP</th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>

    <!-- Timeline view -->
    <div class="timeline hidden" id="timeline">
      <!-- items injectés -->
    </div>
  </div>

  <div class="audit-foot">
    <div id="count">0 événement</div>
    <div class="pager">
      <button class="btn ghost" id="prev" disabled>◀</button>
      <span id="page">1 / 1</span>
      <button class="btn ghost" id="next" disabled>▶</button>
    </div>
  </div>
</div>

<!-- Chart.js pour les donuts -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
(() => {
  const rowsEl   = document.getElementById('rows');
  const qEl      = document.getElementById('q');
  const linesEl  = document.getElementById('lines');
  const liveEl   = document.getElementById('live');
  const pills    = [...document.querySelectorAll('.pill')];
  const countEl  = document.getElementById('count');
  const pageEl   = document.getElementById('page');
  const prevEl   = document.getElementById('prev');
  const nextEl   = document.getElementById('next');
  const exportBtn= document.getElementById('export');

  const donutInfo = new Chart(document.getElementById('donutInfo').getContext('2d'), donutCfg('#60a5fa'));
  const donutWarn = new Chart(document.getElementById('donutWarn').getContext('2d'), donutCfg('#f59e0b'));
  const donutErr  = new Chart(document.getElementById('donutErr').getContext('2d'), donutCfg('#ef4444'));
  const countInfoEl = document.getElementById('countInfo');
  const countWarnEl = document.getElementById('countWarn');
  const countErrEl  = document.getElementById('countErr');

  const tableWrap = document.getElementById('tableWrap');
  const tableEl   = document.getElementById('auditTable');
  const timeline  = document.getElementById('timeline');
  const toggleBtn = document.getElementById('toggleView');

  let source = 'systemd';
  let allItems = [];  // objets parsés
  let page = 1, perPage = 50, pages = 1;
  let es = null;      // EventSource

  function donutCfg(color){
    return {
      type: 'doughnut',
      data: { labels: ['val','reste'], datasets: [{ data: [0,1], borderWidth: 0, backgroundColor: [color, '#eef2ff'] }]},
      options: { cutout: '72%', responsive: false, plugins: { legend: { display:false }, tooltip: { enabled:false } } }
    };
  }

  function setActivePill() {
    pills.forEach(p => p.classList.toggle('is-active', p.dataset.source === source));
  }

  function clsFor(type){
    return ({
      ok:'ok', info:'info', warn:'warn', error:'error',
      start:'ok', stop:'warn', update:'info'
    })[type] || 'info';
  }

  function sevDot(type){
    return `<span class="sev-dot ${clsFor(type)}" title="${type.toUpperCase()}"></span>`;
  }

  function badge(type){
    return `<span class="badge ${clsFor(type)}">${type.toUpperCase()}</span>`;
  }

  // --- Parsers tolérants ---
  const reTime = /^[A-Z][a-z]{2}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2}/; // ex "Aug 18 18:12:34"
  function parseSystemd(line){
    const ts = (line.match(reTime)||[''])[0];
    let msg = line.split(': ').slice(1).join(': ') || line;
    let type='info', actor='';
    if (/Started WireGuard|interface is up|Activating/i.test(msg)) type='start';
    else if (/Stopped WireGuard|Deactivated|Stopping/i.test(msg)) type='stop';
    else if (/Failed|error|cannot|denied/i.test(msg)) type='error';
    else if (/peer|handshake|route|address/i.test(msg)) type='update';
    const ip = msg.match(/\b\d{1,3}(?:\.\d{1,3}){3}(?::\d+)?\b/);
    if (ip) actor = ip[0];
    return { ts, src:'systemd', type, msg, actor };
  }
  function parseKernel(line){
    const ts = (line.match(reTime)||[''])[0];
    let msg = line.replace(/^.*?:\s*/,'');
    let type='info', actor='';
    if (/handshake|keepalive|Receiving/i.test(msg)) type='update';
    else if (/error|invalid/i.test(msg)) type='error';
    const ip = msg.match(/\b\d{1,3}(?:\.\d{1,3}){3}\b/);
    if (ip) actor = ip[0];
    return { ts, src:'kernel', type, msg, actor };
  }
  function parseWG(line){
    const ts = new Date().toLocaleString();
    let type='info', actor='';
    if (/handshake/i.test(line)) type='update';
    if (/error|fail/i.test(line)) type='error';
    const ip = line.match(/\b\d{1,3}(?:\.\d{1,3}){3}\b/);
    if (ip) actor = ip[0];
    return { ts, src:'wg', type, msg: line, actor };
  }

  function computeSummary(items){
    let info=0,warn=0,err=0;
    for (const i of items){
      if (i.type==='error') err++;
      else if (i.type==='warn' || i.type==='stop') warn++;
      else info++;
    }
    // donuts: on remplit proportionnellement (evite 0/0)
    const total = Math.max(1, info+warn+err);
    donutInfo.data.datasets[0].data = [info, total-info]; donutInfo.update();
    donutWarn.data.datasets[0].data = [warn, total-warn]; donutWarn.update();
    donutErr.data.datasets[0].data  = [err,  total-err];  donutErr.update();
    countInfoEl.textContent = info; countWarnEl.textContent = warn; countErrEl.textContent = err;
  }

  function render(){
    // pagination
    pages = Math.max(1, Math.ceil(allItems.length / perPage));
    if (page > pages) page = pages;
    const start = (page-1)*perPage, end = start+perPage;
    const slice = allItems.slice(start, end);

    // table
    rowsEl.innerHTML = slice.map(it => `
      <tr class="sev-${clsFor(it.type)}">
        <td>${sevDot(it.type)}</td>
        <td class="mono">${it.ts || ''}</td>
        <td><span class="tag ${it.src}">${it.src}</span></td>
        <td>${badge(it.type)}</td>
        <td>${escapeHtml(it.msg)}</td>
        <td class="mono">${it.actor||''}</td>
      </tr>
    `).join('');

    // timeline
    timeline.innerHTML = slice.map(it => `
      <div class="tl-item">
        <div class="tl-dot ${clsFor(it.type)}"></div>
        <div class="tl-card">
          <div class="tl-head">
            <span class="mono">${it.ts||''}</span>
            <span class="tag ${it.src}">${it.src}</span>
            ${badge(it.type)}
            <span class="spacer"></span>
            <span class="mono">${it.actor||''}</span>
          </div>
          <div class="tl-msg">${escapeHtml(it.msg)}</div>
        </div>
      </div>
    `).join('');

    computeSummary(slice);

    countEl.textContent = `${allItems.length} événement${allItems.length>1?'s':''}`;
    pageEl.textContent = `${page} / ${pages}`;
    prevEl.disabled = (page<=1);
    nextEl.disabled = (page>=pages);
  }

  function escapeHtml(s){ return (s||'').replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }

  async function loadOnce(){
    if (es) { es.close(); es=null; }
    const r = await fetch(`/logs/api?source=${source}&lines=${encodeURIComponent(linesEl.value)}&q=${encodeURIComponent(qEl.value.trim())}`);
    const text = await r.text();
    const lines = text.split(/\r?\n/).filter(Boolean);

    if (source==='systemd') allItems = lines.map(parseSystemd);
    else if (source==='kernel') allItems = lines.map(parseKernel);
    else allItems = lines.map(parseWG);

    page = 1; render();
  }

  function startLive(){
    if (es) es.close();
    es = new EventSource(`/logs/stream?source=${source}`);
    es.onmessage = (evt) => {
      const line = evt.data;
      if (!line) return;
      let obj = (source==='systemd') ? parseSystemd(line)
              : (source==='kernel') ? parseKernel(line)
              : parseWG(line);
      if (qEl.value && !line.toLowerCase().includes(qEl.value.toLowerCase())) return;
      allItems.unshift(obj);
      if (allItems.length > 1000) allItems.pop();
      render();
    };
  }

  // events
  pills.forEach(p => p.addEventListener('click', () => {
    source = p.dataset.source; setActivePill();
    liveEl.checked ? startLive() : loadOnce();
  }));
  qEl.addEventListener('input', () => liveEl.checked ? null : loadOnce());
  linesEl.addEventListener('change', () => liveEl.checked ? null : loadOnce());
  liveEl.addEventListener('change', () => liveEl.checked ? startLive() : loadOnce());
  prevEl.addEventListener('click', () => { if(page>1){ page--; render(); } });
  nextEl.addEventListener('click', () => { if(page<pages){ page++; render(); } });
  exportBtn.addEventListener('click', () => {
    const csv = ['timestamp,source,type,message,actor'].concat(
      allItems.map(i => `"${(i.ts||'').replace(/"/g,'""')}","${i.src}","${i.type}","${(i.msg||'').replace(/"/g,'""')}","${i.actor||''}"`)
    ).join('\n');
    const blob = new Blob([csv], {type:'text/csv'});
    const a = Object.assign(document.createElement('a'), {href:URL.createObjectURL(blob), download:`audit_${source}.csv`});
    a.click(); URL.revokeObjectURL(a.href);
  });

  toggleBtn.addEventListener('click', () => {
    const isTimeline = !timeline.classList.contains('hidden');
    if (isTimeline){
      timeline.classList.add('hidden'); tableEl.classList.remove('hidden');
      toggleBtn.textContent = '● Timeline';
    } else {
      tableEl.classList.add('hidden'); timeline.classList.remove('hidden');
      toggleBtn.textContent = '▦ Table';
    }
  });

  function setActivePill(){ pills.forEach(p => p.classList.toggle('is-active', p.dataset.source === source)); }

  setActivePill();
  loadOnce();
})();
</script>
{% endblock %}
